---
title: Interview--前置技术
typora-copy-images-to: Interview--前置技术
tags:
 - BigData
 - Interview
---
# JavaSE
### 1.HashMap底层源码，数据结构

HashMap在底层结构中jdk1.7中由数组+链表实现，在jdk1.8中由数组+链表+红黑树实现
以数组+链表的结构为例
<!-- TODO 配图 -->


### 2.Java自带哪几种线程池
1. new CachedThreadPool
创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。这种类型的线程池特点是：
工作线程的创建数量几乎没有限制（其实也有限制的，数目为Interger. MAX_VALUE）, 这样可灵活的往线程池中添加线程。
如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定的时间（默认为1分钟），则该工作线程将自动终止。终止后，如果你又提交了新的任务，则线程池重新创建一个工作线程。
在使用CachedThreadPool时，一定要注意控制任务的数量，否则，由于大量线程同时运行，很有会造成系统瘫痪。

2. new FixedThreadPool
创建一个指定工作线程数量的线程池。每当提交一个任务就创建一个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中。FixedThreadPool是一个典型且优秀的线程池，它具有线程池提高程序效率和节省创建线程时所耗的开销的优点。但是，*在线程池空闲时，即线程池中没有可运行任务时，它不会释放工作线程，还会占用一定的系统资源*。

3. new SingleThreadExecutor
创建一个单线程化的Executor，即只创建唯一的工作者线程来执行任务，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序（FIFO, LIFO, 优先级）执行。如果这个线程异常结束，会有另一个取代它，保证顺序执行。*单工作线程最大的特点是可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的*。

4. new ScheduleThreadPool
*创建一个定长的线程池，而且支持定时的以及周期性的任务执行，支持定时及周期性任务执行。延迟3秒执行*。

### 3.HashMap和HashTable区别
1. 线程线程安全性不同
HashMap线程不安全，HashTable是线程安全的，七种的方法是Synchronized的，在线程并发的情况下，可以之金额使用HashTable，但是使用HashMap时必须自己增加同步处理

2. 是否提供contains方法
HashMap只有containsValue和containsKey方法，HashTable有contains、containsKey和containsValue三个方法，其中contains和containsValue方法功能相同

3. key和value是否允许null值
HashTable中，key和value都不允许出现null值，HashMap中，null可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为null

4. 数组初始化和扩容机制
HashTable在不指定容量的情况下，默认容量为11，而HashMap是16，HashTable不要求底层数组的数量一定为2的正数次幂，而HashMap则要求一定为2的正数次幂
HashTable扩容时，将容量变为原来的二倍加1，而HashMap扩容时，将容量变为原来的2倍

### 4.TreeSet和HashSet区别
HashSet是采用hash表来实现的。其中的元素没有按顺序排列，add()、remove()以及contains()等方法都是复杂度为O(1)的方法。
TreeSet是采用树结构实现（红黑树算法）。元素是按顺序进行排列，但是add()、remove()以及contains()等方法都是复杂度为O(log (n))的方法。它还提供了一些方法来处理排序的set，如first()，last()，headSet()，tailSet()等等。

### 5.StringBuffer和StringBuilder区别
1. StringBuffer与StringBuilder中的方法和功能完全是等价的。
2. 只是StringBuffer中的方法大都采用了 synchronized 关键字进行修饰，因此是线程安全的，而StringBuilder没有这个修饰，可以被认为是线程不安全的。 
3. 在单线程程序下，StringBuilder效率更快，因为它不需要加锁，不具备多线程安全而StringBuffer则每次都需要判断锁，效率相对更低

### 6.Final Finally Finalize
**final**：修饰符（关键字）有三种用法：修饰类、变量和方法。修饰类时，意味着它不能再派生出新的子类，即不能被继承，因此它和abstract是反义词。修饰变量时，该变量使用中不被改变，必须在声明时给定初值，在引用中只能读取不可修改，即为常量。修饰方法时，也同样只能使用，不能在子类中被重写。
**finally**：通常放在try…catch的后面构造最终执行代码块，这就意味着程序无论正常执行还是发生异常，这里的代码只要JVM不关闭都能执行，可以将释放外部资源的代码写在finally块中。
**finalize**：Object类中定义的方法，Java中允许使用finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在销毁对象时调用的，通过重写finalize() 方法可以整理系统资源或者执行其他清理工作。

### 7.==和equalsqubie
**==** : 如果比较的是基本数据类型，那么比较的是变量的值
如果比较的是引用数据类型，那么比较的是地址值（两个对象是否指向同一块内存）
**equals**:如果没重写equals方法比较的是两个对象的地址值。
如果重写了equals方法后我们往往比较的是对象中的属性的内容
equals方法是从Object类中继承的，默认的实现就是使用==
```java
public boolean equals(Object obj) {
    return(this==obj);
}
```

# Redis
### 1.缓存穿透、缓存雪崩、缓存击穿
1. 缓存穿透
是指查询一个不存在的数据，由于缓存命不中时会去查询数据库，差不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透
解决方案:
①将空对象缓存起来，并给他设置一个很短的过期时间，最长不超过5分钟
②采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免对底层存储系统的查询压力
2. 缓存雪崩
如果缓存集中在一段时间内失效，发生大量的缓存穿透，所有的查询都落在数据库上，就会造成缓存雪崩
解决方案:
尽量让失效的时间点不分布在同一个时间点
3. 缓存击穿
是指一个key非常热点，在不停的扛着大并发，当这个key在失效的瞬间持续的大并发就穿破缓存，直接请求数据库，就像在屏障上凿开一个洞
解决方案:
可以设置key永不过期

### 2.哨兵模式
主从复制中反客为主的自动版，如果主机down掉，哨兵会从从机中选择一台作为主机，并将他设置为其他从机的主机，而且如果原来的主机再次启动的话会成为从机。

### 3.数据类型
| 类型              | 描述                       |
| :---------------- | :------------------------- |
| string            | 字符串                     |
| list              | 可以重复的集合             |
| set               | 不可以重复的集合           |
| hash              | 类似于`Map<String,String>` |
| zset(sorted set） | 带分数的set                |


### 4.持久化
1. RDB持久化
    ①在指定的时间间隔内持久化
    ②服务shutdown会自动持久化
    ③输入bgsave也会持久化
2. AOF:以日志形式记录每个更新操作
    Redis重启时读取这个文件，重新执行新建、修改数据的命令恢复数据
    保存策略: 推荐(并且也是默认)的措施为每秒持续化一次，这种策略可以兼顾速度和安全性
    缺点:
    ①比起RDB占用更多的磁盘空间
    ②恢复备份速度要慢
    ③每次读写都同步的话，有一定的性能压力
    ④存在个别bug，造成恢复不成功
 * 选择策略
 官方推荐，如果对数据不敏感，可以选单独用RDB，不建议单独用AOF，因为可能出现Bug，如果只是做纯内存缓存，可以都不用

### 5.悲观锁
执行前假设当前的操作肯定(或有大概率)会被打断(悲观)，基于这个假设，我们在操作前就会把相关资源锁定，不允许自己执行期间有其他操作干扰

### 6.乐观锁
执行操作前假设操作不会被打断(乐观)，基于这个假设，我么能在做操作前不会锁定资源，万一发生了其他操作的干扰，那么本次操作将被放弃。Redis使用的就是乐观锁

# MySQL
### 1.MyISAM与InnoDB的区别
| 对比项 | MyISAM                                                   | InnoDB                                                                         |
| :----- | :------------------------------------------------------- | :----------------------------------------------------------------------------- |
| 外键   | 不支持                                                   | 支持                                                                           |
| 事务   | 不支持                                                   | 支持                                                                           |
| 行表锁 | 表锁，即使操作一条记录也会锁住整个表，不适合高并发的操作 | 行锁,操作时只锁某一行，不对其它行有影响，适合高并发的操作                      |
| 缓存   | 只缓存索引，不缓存真实数据                               | 不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存大小对性能有决定性的影响 |


### 2.索引
**数据结构 B+Tree**
一般来说能够达到range就可以算是优化了`idx name_deptId`
**口诀**（两个法则加6种索引失效的情况）
全值匹配我最爱，最左前缀要遵守；
带头大哥不能死，中间兄弟不能断；
索引列上少计算，范围之后全失效；
LIKE百分写最右，覆盖索引不写*；
不等空值还有OR，索引影响要注意；
VAR引号不可丢，SQL优化有诀窍。

### 3.b-tree和t+tree的区别
1. B-Tree的关键字、索引和记录是放在一起的，B+Tree的非叶子节点中只有关键字和指向下一个节点的索引，记录只放在叶子节点中
2. 在B-Tree中，越靠近根节点的记录查找时间越快，只要找到关键字即可确定记录的存在，而B+Tree中每个记录的查找时间都是一样的，都需要从根节点走到叶子节点，而且在叶子节点中还要再比较关键字

### 4.redis是单线程的为什么那么快
1. 完全基于内存，绝大部分请求都是纯粹的内存操作，非常快速
2. 数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的
3. 采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗
4. 使用多路I/O复用模型，非阻塞IO
5. 使用底层模型不同，他们之间底层实现方式以及客户端之间通信的应用协议不一样，Redis直接自己构建了VM机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求

### 5.MySQL事务
**事务的基本要素(ACID)**
1. 原子性(Atomicity): 事务开始后所有操作，要么全部做完，要么全部不做，不可能停止在中间环节，事务执行过程中出错，会回滚到事务开始前的状态，所有的操作就像没有发生一样，也就是说事务是不可分割的整体。
2. 一致性(Consistency): 事务开始前和结束后，数据库的完整性约束没有被破坏，比如A向B转账，不可能A扣了钱，B没有收到
3. 隔离性(Isolation): 同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰，比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这种卡转账
4. 持久性(Durability): 事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚

**事务的并发问题**
1. 脏读: 事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据
2. 不可重复读: 事务A多次读取同一数据，事务B在事务A多次读取的过程中，对数据做了更新并提交，导致A多次读取同一数据时，结果不一致
3. 幻读: 系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现多了一条记录没有改过来，就好像发生了幻觉一样，这就是幻读
 * 不可重复读和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增和删除，解决不可重复读的问题只需锁住满足条件就行，解决幻读需要锁表

**MySQL事务隔离级别**

| 事务隔离级别                 | 脏读 | 不可重复读 | 幻读 |
| :--------------------------- | :--- | :--------- | :--- |
| 读未提交（read-uncommitted） | 是   | 是         | 是   |
| 不可重复读（read-committed） | 否   | 是         | 是   |
| 可重复读（repeatable-read）  | 否   | 否         | 是   |
| 串行化（serializable）       | 否   | 否         | 否   |


# JVM


# JUC
### 1.Synchronized与Lock的区别
1. Synchronized能实现的功能Lock都能实现，而且Lock比Synchronized更容易使用、更灵活
2. Synchronized可以自动上锁和解锁，Lock需要手动上锁和解锁

### 2.Runnable和Callable的区别
1. Runnable接口中的方法没有返回值，Callable接口中的方法有返回值
2. Runnable接口中的方法没有抛出异常，Callable接口中的方法跑出了异常
3. Runnable接口中的落地方法是call方法，Callable接口中的落地方法是run方法

### 3.什么是分布式锁
在分布式模型下，数据只有一份(或有限制)，此时需要利用锁的技术控制某一时刻修改数据的进程数，分布式锁可以将标记存在内存，只是该内存不是某个进程分配的内存而是公共内存，如Redis，通过`set(key,value,nx,px,timeout)`方法添加分布式锁

### 4.什么是分布式事务
分布式事务指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点上，简单的说，就是一次一次打的操作由不同的小操作组成，这些小的操作分布在不同的服务器上，且属于不同的应用，分布式事务需要保证这些小操作要么全部都成功，要么全部都失败

