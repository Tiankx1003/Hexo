---
title: Interview--前置技术
typora-copy-images-to: Interview--前置技术
tags:
 - BigData
 - Interview
---
# JavaSE
### 1.HashMap底层源码，数据结构


### 2.Java自带哪几种线程池


### 3.HashMap和HashTable区别


### 4.TreeSet和HashSet区别


### 5.StringBuffer和StringBuilder区别


### 6.Final Finally Finalize

### 7.==和equalsqubie

# Redis
### 1.缓存穿透、缓存雪崩、缓存击穿
1. 缓存穿透
是指查询一个不存在的数据，由于缓存命不中时会去查询数据库，差不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透
解决方案:
①将空对象缓存起来，并给他设置一个很短的过期时间，最长不超过5分钟
②采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免对底层存储系统的查询压力
2. 缓存雪崩
如果缓存集中在一段时间内失效，发生大量的缓存穿透，所有的查询都落在数据库上，就会造成缓存雪崩
解决方案:
尽量让失效的时间点不分布在同一个时间点
3. 缓存击穿
是指一个key非常热点，在不停的扛着大并发，当这个key在失效的瞬间持续的大并发就穿破缓存，直接请求数据库，就像在屏障上凿开一个洞
解决方案:
可以设置key永不过期

### 2.哨兵模式
主从复制中反客为主的自动版，如果主机down掉，哨兵会从从机中选择一台作为主机，并将他设置为其他从机的主机，而且如果原来的主机再次启动的话会成为从机。

### 3.数据类型
| 类型              | 描述                       |
| :---------------- | :------------------------- |
| string            | 字符串                     |
| list              | 可以重复的集合             |
| set               | 不可以重复的集合           |
| hash              | 类似于`Map<String,String>` |
| zset(sorted set） | 带分数的set                |


### 4.持久化
1. RDB持久化
  ①在指定的时间间隔内持久化
  ②服务shutdown会自动持久化
  ③输入bgsave也会持久化
2. AOF:以日志形式记录每个更新操作
  Redis重启时读取这个文件，重新执行新建、修改数据的命令恢复数据
  保存策略: 推荐(并且也是默认)的措施为每秒持续化一次，这种策略可以兼顾速度和安全性
  缺点:
    ①比起RDB占用更多的磁盘空间
    ②恢复备份速度要慢
    ③每次读写都同步的话，有一定的性能压力
    ④存在个别bug，造成恢复不成功
 * 选择策略
 官方推荐，如果对数据不敏感，可以选单独用RDB，不建议单独用AOF，因为可能出现Bug，如果只是做纯内存缓存，可以都不用

### 5.悲观锁
执行前假设当前的操作肯定(或有大概率)会被打断(悲观)，基于这个假设，我们在操作前就会把相关资源锁定，不允许自己执行期间有其他操作干扰

### 6.乐观锁
执行操作前假设操作不会被打断(乐观)，基于这个假设，我么能在做操作前不会锁定资源，万一发生了其他操作的干扰，那么本次操作将被放弃。Redis使用的就是乐观锁

# MySQL
### 1.MyISAM与InnoDB的区别
| 对比项 | MyISAM                                                   | InnoDB                                                                         |
| :----- | :------------------------------------------------------- | :----------------------------------------------------------------------------- |
| 外键   | 不支持                                                   | 支持                                                                           |
| 事务   | 不支持                                                   | 支持                                                                           |
| 行表锁 | 表锁，即使操作一条记录也会锁住整个表，不适合高并发的操作 | 行锁,操作时只锁某一行，不对其它行有影响，适合高并发的操作                      |
| 缓存   | 只缓存索引，不缓存真实数据                               | 不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存大小对性能有决定性的影响 |


### 2.索引
**数据结构 B+Tree**
一般来说能够达到range就可以算是优化了`idx name_deptId`
**口诀**（两个法则加6种索引失效的情况）
全值匹配我最爱，最左前缀要遵守；
带头大哥不能死，中间兄弟不能断；
索引列上少计算，范围之后全失效；
LIKE百分写最右，覆盖索引不写*；
不等空值还有OR，索引影响要注意；
VAR引号不可丢，SQL优化有诀窍。

### 3.b-tree和t+tree的区别
1. B-Tree的关键字、索引和记录是放在一起的，B+Tree的非叶子节点中只有关键字和指向下一个节点的索引，记录只放在叶子节点中
2. 在B-Tree中，越靠近根节点的记录查找时间越快，只要找到关键字即可确定记录的存在，而B+Tree中每个记录的查找时间都是一样的，都需要从根节点走到叶子节点，而且在叶子节点中还要再比较关键字

### 4.redis是单线程的为什么那么快
1. 完全基于内存，绝大部分请求都是纯粹的内存操作，非常快速
2. 数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的
3. 采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗
4. 使用多路I/O复用模型，非阻塞IO
5. 使用底层模型不同，他们之间底层实现方式以及客户端之间通信的应用协议不一样，Redis直接自己构建了VM机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求

### 5.MySQL事务
**事务的基本要素(ACID)**
1. 原子性(Atomicity): 事务开始后所有操作，要么全部做完，要么全部不做，不可能停止在中间环节，事务执行过程中出错，会回滚到事务开始前的状态，所有的操作就像没有发生一样，也就是说事务是不可分割的整体。
2. 一致性(Consistency): 事务开始前和结束后，数据库的完整性约束没有被破坏，比如A向B转账，不可能A扣了钱，B没有收到
3. 隔离性(Isolation): 同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰，比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这种卡转账
4. 持久性(Durability): 事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚

**事务的并发问题**
1. 脏读: 事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据
2. 不可重复读: 事务A多次读取同一数据，事务B在事务A多次读取的过程中，对数据做了更新并提交，导致A多次读取同一数据时，结果不一致
3. 幻读: 系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现多了一条记录没有改过来，就好像发生了幻觉一样，这就是幻读
 * 不可重复读和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增和删除，解决不可重复读的问题只需锁住满足条件就行，解决幻读需要锁表

**MySQL事务隔离级别**

| 事务隔离级别                 | 脏读 | 不可重复读 | 幻读 |
| :--------------------------- | :--- | :--------- | :--- |
| 读未提交（read-uncommitted） | 是   | 是         | 是   |
| 不可重复读（read-committed） | 否   | 是         | 是   |
| 可重复读（repeatable-read）  | 否   | 否         | 是   |
| 串行化（serializable）       | 否   | 否         | 否   |


# JVM


# JUC
### 1.Synchronized与Lock的区别
1. Synchronized能实现的功能Lock都能实现，而且Lock比Synchronized更容易使用、更灵活
2. Synchronized可以自动上锁和解锁，Lock需要手动上锁和解锁

### 2.Runnable和Callable的区别
1. Runnable接口中的方法没有返回值，Callable接口中的方法有返回值
2. Runnable接口中的方法没有抛出异常，Callable接口中的方法跑出了异常
3. Runnable接口中的落地方法是call方法，Callable接口中的落地方法是run方法

### 3.什么是分布式锁
在分布式模型下，数据只有一份(或有限制)，此时需要利用锁的技术控制某一时刻修改数据的进程数，分布式锁可以将标记存在内存，只是该内存不是某个进程分配的内存而是公共内存，如Redis，通过`set(key,value,nx,px,timeout)`方法添加分布式锁

### 4.什么是分布式事务
分布式事务指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点上，简单的说，就是一次一次打的操作由不同的小操作

